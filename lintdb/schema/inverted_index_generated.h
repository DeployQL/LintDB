// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_INVERTEDINDEX_LINTDB_H_
#define FLATBUFFERS_GENERATED_INVERTEDINDEX_LINTDB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(
        FLATBUFFERS_VERSION_MAJOR == 23 && FLATBUFFERS_VERSION_MINOR == 5 &&
                FLATBUFFERS_VERSION_REVISION == 26,
        "Non-compatible flatbuffers version included");

namespace lintdb {

struct InvertedIndexDocument;
struct InvertedIndexDocumentBuilder;

struct InvertedIndexDocument FLATBUFFERS_FINAL_CLASS
        : private ::flatbuffers::Table {
    typedef InvertedIndexDocumentBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_CODES = 4
    };
    const ::flatbuffers::Vector<uint32_t>* codes() const {
        return GetPointer<const ::flatbuffers::Vector<uint32_t>*>(VT_CODES);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CODES) &&
                verifier.VerifyVector(codes()) && verifier.EndTable();
    }
};

struct InvertedIndexDocumentBuilder {
    typedef InvertedIndexDocument Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_codes(
            ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> codes) {
        fbb_.AddOffset(InvertedIndexDocument::VT_CODES, codes);
    }
    explicit InvertedIndexDocumentBuilder(
            ::flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<InvertedIndexDocument> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<InvertedIndexDocument>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<InvertedIndexDocument> CreateInvertedIndexDocument(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> codes = 0) {
    InvertedIndexDocumentBuilder builder_(_fbb);
    builder_.add_codes(codes);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<InvertedIndexDocument>
CreateInvertedIndexDocumentDirect(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<uint32_t>* codes = nullptr) {
    auto codes__ = codes ? _fbb.CreateVector<uint32_t>(*codes) : 0;
    return lintdb::CreateInvertedIndexDocument(_fbb, codes__);
}

inline const lintdb::InvertedIndexDocument* GetInvertedIndexDocument(
        const void* buf) {
    return ::flatbuffers::GetRoot<lintdb::InvertedIndexDocument>(buf);
}

inline const lintdb::InvertedIndexDocument* GetSizePrefixedInvertedIndexDocument(
        const void* buf) {
    return ::flatbuffers::GetSizePrefixedRoot<lintdb::InvertedIndexDocument>(
            buf);
}

inline bool VerifyInvertedIndexDocumentBuffer(
        ::flatbuffers::Verifier& verifier) {
    return verifier.VerifyBuffer<lintdb::InvertedIndexDocument>(nullptr);
}

inline bool VerifySizePrefixedInvertedIndexDocumentBuffer(
        ::flatbuffers::Verifier& verifier) {
    return verifier.VerifySizePrefixedBuffer<lintdb::InvertedIndexDocument>(
            nullptr);
}

inline void FinishInvertedIndexDocumentBuffer(
        ::flatbuffers::FlatBufferBuilder& fbb,
        ::flatbuffers::Offset<lintdb::InvertedIndexDocument> root) {
    fbb.Finish(root);
}

inline void FinishSizePrefixedInvertedIndexDocumentBuffer(
        ::flatbuffers::FlatBufferBuilder& fbb,
        ::flatbuffers::Offset<lintdb::InvertedIndexDocument> root) {
    fbb.FinishSizePrefixed(root);
}

} // namespace lintdb

#endif // FLATBUFFERS_GENERATED_INVERTEDINDEX_LINTDB_H_
