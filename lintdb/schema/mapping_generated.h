// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MAPPING_LINTDB_H_
#define FLATBUFFERS_GENERATED_MAPPING_LINTDB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(
        FLATBUFFERS_VERSION_MAJOR == 23 && FLATBUFFERS_VERSION_MINOR == 5 &&
                FLATBUFFERS_VERSION_REVISION == 26,
        "Non-compatible flatbuffers version included");

namespace lintdb {

struct DocumentClusterMapping;
struct DocumentClusterMappingBuilder;

struct DocumentClusterMapping FLATBUFFERS_FINAL_CLASS
        : private ::flatbuffers::Table {
    typedef DocumentClusterMappingBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_CENTROIDS = 4
    };
    const ::flatbuffers::Vector<int64_t>* centroids() const {
        return GetPointer<const ::flatbuffers::Vector<int64_t>*>(VT_CENTROIDS);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const {
        return VerifyTableStart(verifier) &&
                VerifyOffset(verifier, VT_CENTROIDS) &&
                verifier.VerifyVector(centroids()) && verifier.EndTable();
    }
};

struct DocumentClusterMappingBuilder {
    typedef DocumentClusterMapping Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_centroids(
            ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> centroids) {
        fbb_.AddOffset(DocumentClusterMapping::VT_CENTROIDS, centroids);
    }
    explicit DocumentClusterMappingBuilder(
            ::flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<DocumentClusterMapping> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<DocumentClusterMapping>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<DocumentClusterMapping>
CreateDocumentClusterMapping(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> centroids = 0) {
    DocumentClusterMappingBuilder builder_(_fbb);
    builder_.add_centroids(centroids);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<DocumentClusterMapping>
CreateDocumentClusterMappingDirect(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<int64_t>* centroids = nullptr) {
    auto centroids__ = centroids ? _fbb.CreateVector<int64_t>(*centroids) : 0;
    return lintdb::CreateDocumentClusterMapping(_fbb, centroids__);
}

inline const lintdb::DocumentClusterMapping* GetDocumentClusterMapping(
        const void* buf) {
    return ::flatbuffers::GetRoot<lintdb::DocumentClusterMapping>(buf);
}

inline const lintdb::DocumentClusterMapping*
GetSizePrefixedDocumentClusterMapping(const void* buf) {
    return ::flatbuffers::GetSizePrefixedRoot<lintdb::DocumentClusterMapping>(
            buf);
}

inline bool VerifyDocumentClusterMappingBuffer(
        ::flatbuffers::Verifier& verifier) {
    return verifier.VerifyBuffer<lintdb::DocumentClusterMapping>(nullptr);
}

inline bool VerifySizePrefixedDocumentClusterMappingBuffer(
        ::flatbuffers::Verifier& verifier) {
    return verifier.VerifySizePrefixedBuffer<lintdb::DocumentClusterMapping>(
            nullptr);
}

inline void FinishDocumentClusterMappingBuffer(
        ::flatbuffers::FlatBufferBuilder& fbb,
        ::flatbuffers::Offset<lintdb::DocumentClusterMapping> root) {
    fbb.Finish(root);
}

inline void FinishSizePrefixedDocumentClusterMappingBuffer(
        ::flatbuffers::FlatBufferBuilder& fbb,
        ::flatbuffers::Offset<lintdb::DocumentClusterMapping> root) {
    fbb.FinishSizePrefixed(root);
}

} // namespace lintdb

#endif // FLATBUFFERS_GENERATED_MAPPING_LINTDB_H_
