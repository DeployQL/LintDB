# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pylintdb
else:
    import _pylintdb

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylintdb.delete_SwigPyIterator

    def value(self):
        return _pylintdb.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _pylintdb.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _pylintdb.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _pylintdb.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _pylintdb.SwigPyIterator_equal(self, x)

    def copy(self):
        return _pylintdb.SwigPyIterator_copy(self)

    def next(self):
        return _pylintdb.SwigPyIterator_next(self)

    def __next__(self):
        return _pylintdb.SwigPyIterator___next__(self)

    def previous(self):
        return _pylintdb.SwigPyIterator_previous(self)

    def advance(self, n):
        return _pylintdb.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _pylintdb.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _pylintdb.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _pylintdb.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _pylintdb.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _pylintdb.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _pylintdb.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pylintdb:
_pylintdb.SwigPyIterator_swigregister(SwigPyIterator)
class MetadataMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pylintdb.MetadataMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pylintdb.MetadataMap___nonzero__(self)

    def __bool__(self):
        return _pylintdb.MetadataMap___bool__(self)

    def __len__(self):
        return _pylintdb.MetadataMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _pylintdb.MetadataMap___getitem__(self, key)

    def __delitem__(self, key):
        return _pylintdb.MetadataMap___delitem__(self, key)

    def has_key(self, key):
        return _pylintdb.MetadataMap_has_key(self, key)

    def keys(self):
        return _pylintdb.MetadataMap_keys(self)

    def values(self):
        return _pylintdb.MetadataMap_values(self)

    def items(self):
        return _pylintdb.MetadataMap_items(self)

    def __contains__(self, key):
        return _pylintdb.MetadataMap___contains__(self, key)

    def key_iterator(self):
        return _pylintdb.MetadataMap_key_iterator(self)

    def value_iterator(self):
        return _pylintdb.MetadataMap_value_iterator(self)

    def __setitem__(self, *args):
        return _pylintdb.MetadataMap___setitem__(self, *args)

    def asdict(self):
        return _pylintdb.MetadataMap_asdict(self)

    def __init__(self, *args):
        _pylintdb.MetadataMap_swiginit(self, _pylintdb.new_MetadataMap(*args))

    def empty(self):
        return _pylintdb.MetadataMap_empty(self)

    def size(self):
        return _pylintdb.MetadataMap_size(self)

    def swap(self, v):
        return _pylintdb.MetadataMap_swap(self, v)

    def begin(self):
        return _pylintdb.MetadataMap_begin(self)

    def end(self):
        return _pylintdb.MetadataMap_end(self)

    def rbegin(self):
        return _pylintdb.MetadataMap_rbegin(self)

    def rend(self):
        return _pylintdb.MetadataMap_rend(self)

    def clear(self):
        return _pylintdb.MetadataMap_clear(self)

    def get_allocator(self):
        return _pylintdb.MetadataMap_get_allocator(self)

    def count(self, x):
        return _pylintdb.MetadataMap_count(self, x)

    def erase(self, *args):
        return _pylintdb.MetadataMap_erase(self, *args)

    def find(self, x):
        return _pylintdb.MetadataMap_find(self, x)

    def lower_bound(self, x):
        return _pylintdb.MetadataMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _pylintdb.MetadataMap_upper_bound(self, x)
    __swig_destroy__ = _pylintdb.delete_MetadataMap

# Register MetadataMap in _pylintdb:
_pylintdb.MetadataMap_swigregister(MetadataMap)
class Binarizer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bucket_cutoffs = property(_pylintdb.Binarizer_bucket_cutoffs_get, _pylintdb.Binarizer_bucket_cutoffs_set)
    bucket_weights = property(_pylintdb.Binarizer_bucket_weights_get, _pylintdb.Binarizer_bucket_weights_set)
    avg_residual = property(_pylintdb.Binarizer_avg_residual_get, _pylintdb.Binarizer_avg_residual_set)
    nbits = property(_pylintdb.Binarizer_nbits_get, _pylintdb.Binarizer_nbits_set)
    dim = property(_pylintdb.Binarizer_dim_get, _pylintdb.Binarizer_dim_set)
    reverse_bitmap = property(_pylintdb.Binarizer_reverse_bitmap_get, _pylintdb.Binarizer_reverse_bitmap_set)
    decompression_lut = property(_pylintdb.Binarizer_decompression_lut_get, _pylintdb.Binarizer_decompression_lut_set)

    def __init__(self, *args):
        _pylintdb.Binarizer_swiginit(self, _pylintdb.new_Binarizer(*args))

    def binarize(self, residuals):
        return _pylintdb.Binarizer_binarize(self, residuals)

    def train(self, n, x, dim):
        return _pylintdb.Binarizer_train(self, n, x, dim)

    def save(self, path):
        return _pylintdb.Binarizer_save(self, path)

    def sa_encode(self, n, x, codes):
        return _pylintdb.Binarizer_sa_encode(self, n, x, codes)

    def sa_decode(self, n, codes, x):
        return _pylintdb.Binarizer_sa_decode(self, n, codes, x)

    def code_size(self):
        return _pylintdb.Binarizer_code_size(self)

    def get_nbits(self):
        return _pylintdb.Binarizer_get_nbits(self)

    @staticmethod
    def load(path):
        return _pylintdb.Binarizer_load(path)

    def set_weights(self, weights, cutoffs, avg_residual):
        return _pylintdb.Binarizer_set_weights(self, weights, cutoffs, avg_residual)

    def get_type(self):
        return _pylintdb.Binarizer_get_type(self)
    __swig_destroy__ = _pylintdb.delete_Binarizer

# Register Binarizer in _pylintdb:
_pylintdb.Binarizer_swigregister(Binarizer)

def swap(first, second):
    return _pylintdb.swap(first, second)

class ICoarseQuantizer(object):
    r"""
    ICoarseQuantizer defines the interface for coarse quantization.

    Yes, this needs work to break apart. For now, it's useful in testing and mocking.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def train(self, n, x, k, num_iter):
        return _pylintdb.ICoarseQuantizer_train(self, n, x, k, num_iter)

    def save(self, path):
        return _pylintdb.ICoarseQuantizer_save(self, path)

    def assign(self, n, x, codes):
        return _pylintdb.ICoarseQuantizer_assign(self, n, x, codes)

    def sa_decode(self, n, codes, x):
        return _pylintdb.ICoarseQuantizer_sa_decode(self, n, codes, x)

    def compute_residual(self, vec, residual, centroid_id):
        return _pylintdb.ICoarseQuantizer_compute_residual(self, vec, residual, centroid_id)

    def compute_residual_n(self, n, vec, residual, centroid_ids):
        return _pylintdb.ICoarseQuantizer_compute_residual_n(self, n, vec, residual, centroid_ids)

    def reconstruct(self, centroid_id, embedding):
        return _pylintdb.ICoarseQuantizer_reconstruct(self, centroid_id, embedding)

    def search(self, num_query_tok, data, k_top_centroids, distances, coarse_idx):
        return _pylintdb.ICoarseQuantizer_search(self, num_query_tok, data, k_top_centroids, distances, coarse_idx)

    def reset(self):
        return _pylintdb.ICoarseQuantizer_reset(self)

    def add(self, n, data):
        return _pylintdb.ICoarseQuantizer_add(self, n, data)

    def code_size(self):
        return _pylintdb.ICoarseQuantizer_code_size(self)

    def num_centroids(self):
        return _pylintdb.ICoarseQuantizer_num_centroids(self)

    def get_xb(self):
        return _pylintdb.ICoarseQuantizer_get_xb(self)

    def serialize(self, filename):
        return _pylintdb.ICoarseQuantizer_serialize(self, filename)

    def is_trained(self):
        return _pylintdb.ICoarseQuantizer_is_trained(self)
    __swig_destroy__ = _pylintdb.delete_ICoarseQuantizer

# Register ICoarseQuantizer in _pylintdb:
_pylintdb.ICoarseQuantizer_swigregister(ICoarseQuantizer)
class CoarseQuantizer(ICoarseQuantizer):
    r"""This class is used for IVF of vectors."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_trained_ = property(_pylintdb.CoarseQuantizer_is_trained__get, _pylintdb.CoarseQuantizer_is_trained__set)

    def __init__(self, d):
        _pylintdb.CoarseQuantizer_swiginit(self, _pylintdb.new_CoarseQuantizer(d))

    def train(self, n, x, k, num_iter=10):
        return _pylintdb.CoarseQuantizer_train(self, n, x, k, num_iter)

    def save(self, path):
        return _pylintdb.CoarseQuantizer_save(self, path)

    def assign(self, n, x, codes):
        return _pylintdb.CoarseQuantizer_assign(self, n, x, codes)

    def sa_decode(self, n, codes, x):
        return _pylintdb.CoarseQuantizer_sa_decode(self, n, codes, x)

    def compute_residual(self, vec, residual, centroid_id):
        return _pylintdb.CoarseQuantizer_compute_residual(self, vec, residual, centroid_id)

    def compute_residual_n(self, n, vec, residual, centroid_ids):
        return _pylintdb.CoarseQuantizer_compute_residual_n(self, n, vec, residual, centroid_ids)

    def reconstruct(self, centroid_id, embedding):
        return _pylintdb.CoarseQuantizer_reconstruct(self, centroid_id, embedding)

    def search(self, num_query_tok, data, k_top_centroids, distances, coarse_idx):
        return _pylintdb.CoarseQuantizer_search(self, num_query_tok, data, k_top_centroids, distances, coarse_idx)

    def reset(self):
        return _pylintdb.CoarseQuantizer_reset(self)

    def add(self, n, data):
        return _pylintdb.CoarseQuantizer_add(self, n, data)

    def code_size(self):
        return _pylintdb.CoarseQuantizer_code_size(self)

    def num_centroids(self):
        return _pylintdb.CoarseQuantizer_num_centroids(self)

    def get_xb(self):
        return _pylintdb.CoarseQuantizer_get_xb(self)

    def serialize(self, filename):
        return _pylintdb.CoarseQuantizer_serialize(self, filename)

    @staticmethod
    def deserialize(filename, version):
        return _pylintdb.CoarseQuantizer_deserialize(filename, version)

    def is_trained(self):
        return _pylintdb.CoarseQuantizer_is_trained(self)
    __swig_destroy__ = _pylintdb.delete_CoarseQuantizer

# Register CoarseQuantizer in _pylintdb:
_pylintdb.CoarseQuantizer_swigregister(CoarseQuantizer)
class SearchOptions(object):
    r"""
    SearchOptions enables custom searching behavior.

    These options expose ways to tradeoff recall and latency at different levels
    of retrieval. Searching more centroids:
    - decrease centroid_score_threshold and increase k_top_centroids.
    - increase n_probe in search()

    Decreasing latency:
    - increase centroid_score_threshold and decrease k_top_centroids.
    - decrease n_probe in search()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    expected_id = property(_pylintdb.SearchOptions_expected_id_get, _pylintdb.SearchOptions_expected_id_set)
    centroid_score_threshold = property(_pylintdb.SearchOptions_centroid_score_threshold_get, _pylintdb.SearchOptions_centroid_score_threshold_set, doc=r"""
    expects a document id in the return result.
    prints additional information during execution.
    useful for debugging.
    """)
    k_top_centroids = property(_pylintdb.SearchOptions_k_top_centroids_get, _pylintdb.SearchOptions_k_top_centroids_set, doc=r""" the threshold for centroid scores.""")
    num_second_pass = property(_pylintdb.SearchOptions_num_second_pass_get, _pylintdb.SearchOptions_num_second_pass_set, doc=r""" the number of top centroids to consider per token.""")
    n_probe = property(_pylintdb.SearchOptions_n_probe_get, _pylintdb.SearchOptions_n_probe_set, doc=r""" the number of second pass candidates to consider.""")
    nearest_tokens_to_fetch = property(_pylintdb.SearchOptions_nearest_tokens_to_fetch_get, _pylintdb.SearchOptions_nearest_tokens_to_fetch_set, doc=r""" the number of centroids to search overall.""")
    colbert_field = property(_pylintdb.SearchOptions_colbert_field_get, _pylintdb.SearchOptions_colbert_field_set, doc=r""" the number of nearest tokens to fetch in XTR.""")

    def __init__(self):
        _pylintdb.SearchOptions_swiginit(self, _pylintdb.new_SearchOptions())
    __swig_destroy__ = _pylintdb.delete_SearchOptions

# Register SearchOptions in _pylintdb:
_pylintdb.SearchOptions_swigregister(SearchOptions)
class SearchResult(object):
    r"""SearchResult is a simple struct to hold the results of a search."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_pylintdb.SearchResult_id_get, _pylintdb.SearchResult_id_set)
    score = property(_pylintdb.SearchResult_score_get, _pylintdb.SearchResult_score_set, doc=r""" the document's id.""")
    metadata = property(_pylintdb.SearchResult_metadata_get, _pylintdb.SearchResult_metadata_set, doc=r""" the final score as determined by the database.""")
    token_scores = property(_pylintdb.SearchResult_token_scores_get, _pylintdb.SearchResult_token_scores_set, doc=r"""
    Optionally, metadata that was indexed for the
    document.
    """)

    def __init__(self):
        r""" Document token scores."""
        _pylintdb.SearchResult_swiginit(self, _pylintdb.new_SearchResult())

    def __lt__(self, other):
        return _pylintdb.SearchResult___lt__(self, other)

    def __gt__(self, other):
        return _pylintdb.SearchResult___gt__(self, other)
    __swig_destroy__ = _pylintdb.delete_SearchResult

# Register SearchResult in _pylintdb:
_pylintdb.SearchResult_swigregister(SearchResult)
class Configuration(object):
    r"""Configuration of the Index."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lintdb_version = property(_pylintdb.Configuration_lintdb_version_get, _pylintdb.Configuration_lintdb_version_set)

    def __eq__(self, other):
        r"""
        the current version of the index. Used
        internally for feature compatibility.
        """
        return _pylintdb.Configuration___eq__(self, other)

    def __init__(self):
        _pylintdb.Configuration_swiginit(self, _pylintdb.new_Configuration())
    __swig_destroy__ = _pylintdb.delete_Configuration

# Register Configuration in _pylintdb:
_pylintdb.Configuration_swigregister(Configuration)
cvar = _pylintdb.cvar
METADATA_FILENAME = cvar.METADATA_FILENAME

class IndexIVF(object):
    r"""
    IndexIVF is a multi vector index with an inverted file structure.

    This relies on pretrained centroids to accurately retrieve the closest
    documents.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    config = property(_pylintdb.IndexIVF_config_get, _pylintdb.IndexIVF_config_set)
    read_only = property(_pylintdb.IndexIVF_read_only_get, _pylintdb.IndexIVF_read_only_set)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         load an existing index.

        |

        *Overload 2:*

        Copy creates a new index at the given path from a trained index. The copy
        will always be writeable.

        Will throw an exception if the index isn't trained when this method is
        called.

        :type path: string
        :param path: the path to initialize the index.
        """
        _pylintdb.IndexIVF_swiginit(self, _pylintdb.new_IndexIVF(*args))

    def train(self, docs):
        r"""
        Train will learn quantization and compression parameters from the given
        data.
        """
        return _pylintdb.IndexIVF_train(self, docs)

    def set_quantizer(self, field, quantizer):
        return _pylintdb.IndexIVF_set_quantizer(self, field, quantizer)

    def set_coarse_quantizer(self, field, quantizer):
        return _pylintdb.IndexIVF_set_coarse_quantizer(self, field, quantizer)

    def search(self, *args):
        r"""
        search will find the nearest neighbors for a vector block.

        :type tenant: int
        :param tenant: the tenant the document belongs to.
        :param block: the block of embeddings to search.
        :param n_probe: the number of centroids to search.
        :type k: int
        :param k: the top k results to return.
        :type opts: :py:class:`SearchOptions`, optional
        :param opts: any search options to use during searching.
        """
        return _pylintdb.IndexIVF_search(self, *args)

    def add(self, tenant, docs):
        r"""
        Add will add a block of embeddings to the index.

        :type tenant: int
        :param tenant: the tenant to assign the document to.
        :type docs: std::vector< Document,std::allocator< Document > >
        :param docs: a vector of EmbeddingPassages. This includes embeddings and
            ids.
        """
        return _pylintdb.IndexIVF_add(self, tenant, docs)

    def add_single(self, tenant, doc):
        r"""Add a single document."""
        return _pylintdb.IndexIVF_add_single(self, tenant, doc)

    def remove(self, tenant, ids):
        r"""
        Remove deletes documents from the index by id.

        void remove(const std::vector<int64_t>& ids) works if SWIG complains
        about idx_t.
        """
        return _pylintdb.IndexIVF_remove(self, tenant, ids)

    def update(self, tenant, docs):
        r"""Update is a convenience function for remove and add."""
        return _pylintdb.IndexIVF_update(self, tenant, docs)

    def merge(self, path):
        r"""
        Merge will combine the index with another index.

        We verify that the configuration of each index is correct, but this
        doesn't prevent you from merging indices with different centroids. There
        will be subtle ways for this to break, but this can enable easier
        multiprocess building of indices.
        """
        return _pylintdb.IndexIVF_merge(self, path)

    def save(self):
        r"""
        Index should be able to resume from a previous state.
        Any quantization and compression will be saved within the Index's path.

        Inverted lists are persisted to the database.
        """
        return _pylintdb.IndexIVF_save(self)

    def close(self):
        return _pylintdb.IndexIVF_close(self)
    __swig_destroy__ = _pylintdb.delete_IndexIVF

# Register IndexIVF in _pylintdb:
_pylintdb.IndexIVF_swigregister(IndexIVF)
Indexed = _pylintdb.Indexed
Context = _pylintdb.Context
Stored = _pylintdb.Stored
Colbert = _pylintdb.Colbert
class FieldParameters(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dimensions = property(_pylintdb.FieldParameters_dimensions_get, _pylintdb.FieldParameters_dimensions_set)
    analyzer = property(_pylintdb.FieldParameters_analyzer_get, _pylintdb.FieldParameters_analyzer_set)
    quantization = property(_pylintdb.FieldParameters_quantization_get, _pylintdb.FieldParameters_quantization_set)
    num_centroids = property(_pylintdb.FieldParameters_num_centroids_get, _pylintdb.FieldParameters_num_centroids_set)
    num_iterations = property(_pylintdb.FieldParameters_num_iterations_get, _pylintdb.FieldParameters_num_iterations_set)
    num_subquantizers = property(_pylintdb.FieldParameters_num_subquantizers_get, _pylintdb.FieldParameters_num_subquantizers_set)
    nbits = property(_pylintdb.FieldParameters_nbits_get, _pylintdb.FieldParameters_nbits_set)

    def __init__(self):
        _pylintdb.FieldParameters_swiginit(self, _pylintdb.new_FieldParameters())
    __swig_destroy__ = _pylintdb.delete_FieldParameters

# Register FieldParameters in _pylintdb:
_pylintdb.FieldParameters_swigregister(FieldParameters)
class Field(object):
    r"""A Schema is made up of multiple fields."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_pylintdb.Field_name_get, _pylintdb.Field_name_set)
    data_type = property(_pylintdb.Field_data_type_get, _pylintdb.Field_data_type_set, doc=r""" the name of the field""")
    field_types = property(_pylintdb.Field_field_types_get, _pylintdb.Field_field_types_set, doc=r""" the data type. e.g. int, float, string, embedding.""")
    parameters = property(_pylintdb.Field_parameters_get, _pylintdb.Field_parameters_set, doc=r""" the field types. e.g. indexed or stored in the database.""")

    def toJson(self):
        r""" parameters for the field."""
        return _pylintdb.Field_toJson(self)

    @staticmethod
    def fromJson(json):
        return _pylintdb.Field_fromJson(json)

    def __init__(self):
        _pylintdb.Field_swiginit(self, _pylintdb.new_Field())
    __swig_destroy__ = _pylintdb.delete_Field

# Register Field in _pylintdb:
_pylintdb.Field_swigregister(Field)
class Schema(object):
    r"""
    A schema dictates what data is stored, how it is stored, and the way we are
    able to interact with the data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fields = property(_pylintdb.Schema_fields_get, _pylintdb.Schema_fields_set)

    def toJson(self):
        return _pylintdb.Schema_toJson(self)

    @staticmethod
    def fromJson(json):
        return _pylintdb.Schema_fromJson(json)

    def add_field(self, field):
        return _pylintdb.Schema_add_field(self, field)

    def __init__(self):
        _pylintdb.Schema_swiginit(self, _pylintdb.new_Schema())
    __swig_destroy__ = _pylintdb.delete_Schema

# Register Schema in _pylintdb:
_pylintdb.Schema_swigregister(Schema)
MAX_TENSOR_SIZE = _pylintdb.MAX_TENSOR_SIZE
MAX_CENTROIDS_TO_STORE = _pylintdb.MAX_CENTROIDS_TO_STORE
TENSOR = _pylintdb.TENSOR
QUANTIZED_TENSOR = _pylintdb.QUANTIZED_TENSOR
INTEGER = _pylintdb.INTEGER
FLOAT = _pylintdb.FLOAT
TEXT = _pylintdb.TEXT
DATETIME = _pylintdb.DATETIME
COLBERT = _pylintdb.COLBERT
class ColBERTContextData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    doc_codes = property(_pylintdb.ColBERTContextData_doc_codes_get, _pylintdb.ColBERTContextData_doc_codes_set)
    doc_residuals = property(_pylintdb.ColBERTContextData_doc_residuals_get, _pylintdb.ColBERTContextData_doc_residuals_set)

    def __init__(self):
        _pylintdb.ColBERTContextData_swiginit(self, _pylintdb.new_ColBERTContextData())
    __swig_destroy__ = _pylintdb.delete_ColBERTContextData

# Register ColBERTContextData in _pylintdb:
_pylintdb.ColBERTContextData_swigregister(ColBERTContextData)
IntToDataType = cvar.IntToDataType
DataTypeToInt = cvar.DataTypeToInt

class FieldValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data_type = property(_pylintdb.FieldValue_data_type_get, _pylintdb.FieldValue_data_type_set)
    num_tensors = property(_pylintdb.FieldValue_num_tensors_get, _pylintdb.FieldValue_num_tensors_set)
    value = property(_pylintdb.FieldValue_value_get, _pylintdb.FieldValue_value_set)

    def __init__(self, *args):
        _pylintdb.FieldValue_swiginit(self, _pylintdb.new_FieldValue(*args))
    __swig_destroy__ = _pylintdb.delete_FieldValue

# Register FieldValue in _pylintdb:
_pylintdb.FieldValue_swigregister(FieldValue)

